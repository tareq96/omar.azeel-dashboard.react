/**
 * Generated by orval v7.16.0 üç∫
 * Do not edit manually.
 * Laravel
 * OpenAPI spec version: 0.0.1
 */
import { useMutation, useQuery } from "@tanstack/react-query";
import type {
  DataTag,
  DefinedInitialDataOptions,
  DefinedUseQueryResult,
  MutationFunction,
  QueryClient,
  QueryFunction,
  QueryKey,
  UndefinedInitialDataOptions,
  UseMutationOptions,
  UseMutationResult,
  UseQueryOptions,
  UseQueryResult,
} from "@tanstack/react-query";

import type {
  AdminUsersUpdate1200,
  AdminUsersUpdate1Body,
  AdminUsersUpdate2200,
  AdminUsersUpdate2Body,
  AdminUsersUpdateCustomer1200,
  AdminUsersUpdateCustomer1Body,
  AdminUsersUpdateCustomer2200,
  AdminUsersUpdateCustomer2Body,
  AuthenticationExceptionResponse,
  ModelNotFoundExceptionResponse,
  UsersChangeCustomerBundle200,
  UsersChangeCustomerBundleBody,
  UsersDetachCustomerBundle200,
  UsersGetCustomerBundles200,
  UsersGetCustomerBundlesParams,
  UsersGetCustomers200,
  UsersGetCustomersParams,
  UsersGetDrivers200,
  UsersGetDriversParams,
  UsersGetMemberships200,
  UsersGetMembershipsParams,
  UsersGetPermissions200,
  UsersGetUserTrips200,
  UsersGetUserTripsParams,
  UsersGetUsers200,
  UsersGetUsersParams,
  UsersShow200,
  UsersShowCustomer200,
  UsersStore201,
  UsersStoreBody,
  UsersStoreCustomer201,
  UsersStoreCustomerBody,
  UsersUpdateMembershipExtraItems200,
  UsersUpdateMembershipExtraItemsBody,
  UsersUpdateSuspension200,
  UsersUpdateSuspensionBody,
  ValidationExceptionResponse,
} from "../azeel.schemas";

import { customInstance } from "../../base/orvalMutator";
import type { ErrorType, BodyType } from "../../base/orvalMutator";
import { infiniteOptions } from "../../base/orvalMutator";

type SecondParameter<T extends (...args: never) => unknown> = Parameters<T>[1];

export const usersGetUsers = (
  params?: UsersGetUsersParams,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<UsersGetUsers200>(
    { url: `/users`, method: "GET", params, signal },
    options,
  );
};

export const getUsersGetUsersQueryKey = (params?: UsersGetUsersParams) => {
  return [`/users`, ...(params ? [params] : [])] as const;
};

export const useUsersGetUsersQueryOptions = <
  TData = Awaited<ReturnType<typeof usersGetUsers>>,
  TError = ErrorType<AuthenticationExceptionResponse | ValidationExceptionResponse>,
>(
  params?: UsersGetUsersParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof usersGetUsers>>, TError, TData>>;
    request?: SecondParameter<typeof customInstance>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getUsersGetUsersQueryKey(params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof usersGetUsers>>> = ({ signal }) =>
    usersGetUsers(params, requestOptions, signal);

  const customOptions = infiniteOptions({ ...queryOptions, queryKey, queryFn });

  return customOptions as UseQueryOptions<
    Awaited<ReturnType<typeof usersGetUsers>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type UsersGetUsersQueryResult = NonNullable<Awaited<ReturnType<typeof usersGetUsers>>>;
export type UsersGetUsersQueryError = ErrorType<
  AuthenticationExceptionResponse | ValidationExceptionResponse
>;

export function useUsersGetUsers<
  TData = Awaited<ReturnType<typeof usersGetUsers>>,
  TError = ErrorType<AuthenticationExceptionResponse | ValidationExceptionResponse>,
>(
  params: undefined | UsersGetUsersParams,
  options: {
    query: Partial<UseQueryOptions<Awaited<ReturnType<typeof usersGetUsers>>, TError, TData>> &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof usersGetUsers>>,
          TError,
          Awaited<ReturnType<typeof usersGetUsers>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useUsersGetUsers<
  TData = Awaited<ReturnType<typeof usersGetUsers>>,
  TError = ErrorType<AuthenticationExceptionResponse | ValidationExceptionResponse>,
>(
  params?: UsersGetUsersParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof usersGetUsers>>, TError, TData>> &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof usersGetUsers>>,
          TError,
          Awaited<ReturnType<typeof usersGetUsers>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useUsersGetUsers<
  TData = Awaited<ReturnType<typeof usersGetUsers>>,
  TError = ErrorType<AuthenticationExceptionResponse | ValidationExceptionResponse>,
>(
  params?: UsersGetUsersParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof usersGetUsers>>, TError, TData>>;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

export function useUsersGetUsers<
  TData = Awaited<ReturnType<typeof usersGetUsers>>,
  TError = ErrorType<AuthenticationExceptionResponse | ValidationExceptionResponse>,
>(
  params?: UsersGetUsersParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof usersGetUsers>>, TError, TData>>;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = useUsersGetUsersQueryOptions(params, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary Store a new user via Admin API.
POST: /api/admin/users
 */
export const usersStore = (
  usersStoreBody: BodyType<UsersStoreBody>,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<UsersStore201>(
    {
      url: `/users`,
      method: "POST",
      headers: { "Content-Type": "application/json" },
      data: usersStoreBody,
      signal,
    },
    options,
  );
};

export const getUsersStoreMutationOptions = <
  TError = ErrorType<AuthenticationExceptionResponse | ValidationExceptionResponse>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof usersStore>>,
    TError,
    { data: BodyType<UsersStoreBody> },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof usersStore>>,
  TError,
  { data: BodyType<UsersStoreBody> },
  TContext
> => {
  const mutationKey = ["usersStore"];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && "mutationKey" in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof usersStore>>,
    { data: BodyType<UsersStoreBody> }
  > = (props) => {
    const { data } = props ?? {};

    return usersStore(data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type UsersStoreMutationResult = NonNullable<Awaited<ReturnType<typeof usersStore>>>;
export type UsersStoreMutationBody = BodyType<UsersStoreBody>;
export type UsersStoreMutationError = ErrorType<
  AuthenticationExceptionResponse | ValidationExceptionResponse
>;

/**
 * @summary Store a new user via Admin API.
POST: /api/admin/users
 */
export const useUsersStore = <
  TError = ErrorType<AuthenticationExceptionResponse | ValidationExceptionResponse>,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof usersStore>>,
      TError,
      { data: BodyType<UsersStoreBody> },
      TContext
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof usersStore>>,
  TError,
  { data: BodyType<UsersStoreBody> },
  TContext
> => {
  const mutationOptions = getUsersStoreMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};
/**
 * @summary Show user details: image, name, mobile, email, type, zones.
GET: /api/admin/users/{user}
 */
export const usersShow = (
  user: number,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<UsersShow200>({ url: `/users/${user}`, method: "GET", signal }, options);
};

export const getUsersShowQueryKey = (user?: number) => {
  return [`/users/${user}`] as const;
};

export const useUsersShowQueryOptions = <
  TData = Awaited<ReturnType<typeof usersShow>>,
  TError = ErrorType<AuthenticationExceptionResponse | ModelNotFoundExceptionResponse>,
>(
  user: number,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof usersShow>>, TError, TData>>;
    request?: SecondParameter<typeof customInstance>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getUsersShowQueryKey(user);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof usersShow>>> = ({ signal }) =>
    usersShow(user, requestOptions, signal);

  const customOptions = infiniteOptions({ ...queryOptions, queryKey, queryFn });

  return customOptions as UseQueryOptions<Awaited<ReturnType<typeof usersShow>>, TError, TData> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };
};

export type UsersShowQueryResult = NonNullable<Awaited<ReturnType<typeof usersShow>>>;
export type UsersShowQueryError = ErrorType<
  AuthenticationExceptionResponse | ModelNotFoundExceptionResponse
>;

export function useUsersShow<
  TData = Awaited<ReturnType<typeof usersShow>>,
  TError = ErrorType<AuthenticationExceptionResponse | ModelNotFoundExceptionResponse>,
>(
  user: number,
  options: {
    query: Partial<UseQueryOptions<Awaited<ReturnType<typeof usersShow>>, TError, TData>> &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof usersShow>>,
          TError,
          Awaited<ReturnType<typeof usersShow>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useUsersShow<
  TData = Awaited<ReturnType<typeof usersShow>>,
  TError = ErrorType<AuthenticationExceptionResponse | ModelNotFoundExceptionResponse>,
>(
  user: number,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof usersShow>>, TError, TData>> &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof usersShow>>,
          TError,
          Awaited<ReturnType<typeof usersShow>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useUsersShow<
  TData = Awaited<ReturnType<typeof usersShow>>,
  TError = ErrorType<AuthenticationExceptionResponse | ModelNotFoundExceptionResponse>,
>(
  user: number,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof usersShow>>, TError, TData>>;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
/**
 * @summary Show user details: image, name, mobile, email, type, zones.
GET: /api/admin/users/{user}
 */

export function useUsersShow<
  TData = Awaited<ReturnType<typeof usersShow>>,
  TError = ErrorType<AuthenticationExceptionResponse | ModelNotFoundExceptionResponse>,
>(
  user: number,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof usersShow>>, TError, TData>>;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = useUsersShowQueryOptions(user, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary Update an existing user via Admin API.
PUT/PATCH: /api/admin/users/{user}
 */
export const adminUsersUpdate1 = (
  user: number,
  adminUsersUpdate1Body: BodyType<AdminUsersUpdate1Body>,
  options?: SecondParameter<typeof customInstance>,
) => {
  return customInstance<AdminUsersUpdate1200>(
    {
      url: `/users/${user}`,
      method: "PUT",
      headers: { "Content-Type": "application/json" },
      data: adminUsersUpdate1Body,
    },
    options,
  );
};

export const getAdminUsersUpdate1MutationOptions = <
  TError = ErrorType<
    AuthenticationExceptionResponse | ModelNotFoundExceptionResponse | ValidationExceptionResponse
  >,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof adminUsersUpdate1>>,
    TError,
    { user: number; data: BodyType<AdminUsersUpdate1Body> },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof adminUsersUpdate1>>,
  TError,
  { user: number; data: BodyType<AdminUsersUpdate1Body> },
  TContext
> => {
  const mutationKey = ["adminUsersUpdate1"];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && "mutationKey" in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof adminUsersUpdate1>>,
    { user: number; data: BodyType<AdminUsersUpdate1Body> }
  > = (props) => {
    const { user, data } = props ?? {};

    return adminUsersUpdate1(user, data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type AdminUsersUpdate1MutationResult = NonNullable<
  Awaited<ReturnType<typeof adminUsersUpdate1>>
>;
export type AdminUsersUpdate1MutationBody = BodyType<AdminUsersUpdate1Body>;
export type AdminUsersUpdate1MutationError = ErrorType<
  AuthenticationExceptionResponse | ModelNotFoundExceptionResponse | ValidationExceptionResponse
>;

/**
 * @summary Update an existing user via Admin API.
PUT/PATCH: /api/admin/users/{user}
 */
export const useAdminUsersUpdate1 = <
  TError = ErrorType<
    AuthenticationExceptionResponse | ModelNotFoundExceptionResponse | ValidationExceptionResponse
  >,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof adminUsersUpdate1>>,
      TError,
      { user: number; data: BodyType<AdminUsersUpdate1Body> },
      TContext
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof adminUsersUpdate1>>,
  TError,
  { user: number; data: BodyType<AdminUsersUpdate1Body> },
  TContext
> => {
  const mutationOptions = getAdminUsersUpdate1MutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};
/**
 * @summary Update an existing user via Admin API.
PUT/PATCH: /api/admin/users/{user}
 */
export const adminUsersUpdate2 = (
  user: number,
  adminUsersUpdate2Body: BodyType<AdminUsersUpdate2Body>,
  options?: SecondParameter<typeof customInstance>,
) => {
  return customInstance<AdminUsersUpdate2200>(
    {
      url: `/users/${user}`,
      method: "PATCH",
      headers: { "Content-Type": "application/json" },
      data: adminUsersUpdate2Body,
    },
    options,
  );
};

export const getAdminUsersUpdate2MutationOptions = <
  TError = ErrorType<
    AuthenticationExceptionResponse | ModelNotFoundExceptionResponse | ValidationExceptionResponse
  >,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof adminUsersUpdate2>>,
    TError,
    { user: number; data: BodyType<AdminUsersUpdate2Body> },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof adminUsersUpdate2>>,
  TError,
  { user: number; data: BodyType<AdminUsersUpdate2Body> },
  TContext
> => {
  const mutationKey = ["adminUsersUpdate2"];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && "mutationKey" in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof adminUsersUpdate2>>,
    { user: number; data: BodyType<AdminUsersUpdate2Body> }
  > = (props) => {
    const { user, data } = props ?? {};

    return adminUsersUpdate2(user, data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type AdminUsersUpdate2MutationResult = NonNullable<
  Awaited<ReturnType<typeof adminUsersUpdate2>>
>;
export type AdminUsersUpdate2MutationBody = BodyType<AdminUsersUpdate2Body>;
export type AdminUsersUpdate2MutationError = ErrorType<
  AuthenticationExceptionResponse | ModelNotFoundExceptionResponse | ValidationExceptionResponse
>;

/**
 * @summary Update an existing user via Admin API.
PUT/PATCH: /api/admin/users/{user}
 */
export const useAdminUsersUpdate2 = <
  TError = ErrorType<
    AuthenticationExceptionResponse | ModelNotFoundExceptionResponse | ValidationExceptionResponse
  >,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof adminUsersUpdate2>>,
      TError,
      { user: number; data: BodyType<AdminUsersUpdate2Body> },
      TContext
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof adminUsersUpdate2>>,
  TError,
  { user: number; data: BodyType<AdminUsersUpdate2Body> },
  TContext
> => {
  const mutationOptions = getAdminUsersUpdate2MutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};
/**
 * @summary List a user's trips with q search.
Returns code, path, status, date, id.
GET: /api/admin/users/{user}/trips
 */
export const usersGetUserTrips = (
  user: number,
  params?: UsersGetUserTripsParams,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<UsersGetUserTrips200>(
    { url: `/users/${user}/trips`, method: "GET", params, signal },
    options,
  );
};

export const getUsersGetUserTripsQueryKey = (user?: number, params?: UsersGetUserTripsParams) => {
  return [`/users/${user}/trips`, ...(params ? [params] : [])] as const;
};

export const useUsersGetUserTripsQueryOptions = <
  TData = Awaited<ReturnType<typeof usersGetUserTrips>>,
  TError = ErrorType<
    AuthenticationExceptionResponse | ModelNotFoundExceptionResponse | ValidationExceptionResponse
  >,
>(
  user: number,
  params?: UsersGetUserTripsParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof usersGetUserTrips>>, TError, TData>>;
    request?: SecondParameter<typeof customInstance>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getUsersGetUserTripsQueryKey(user, params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof usersGetUserTrips>>> = ({ signal }) =>
    usersGetUserTrips(user, params, requestOptions, signal);

  const customOptions = infiniteOptions({ ...queryOptions, queryKey, queryFn });

  return customOptions as UseQueryOptions<
    Awaited<ReturnType<typeof usersGetUserTrips>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type UsersGetUserTripsQueryResult = NonNullable<
  Awaited<ReturnType<typeof usersGetUserTrips>>
>;
export type UsersGetUserTripsQueryError = ErrorType<
  AuthenticationExceptionResponse | ModelNotFoundExceptionResponse | ValidationExceptionResponse
>;

export function useUsersGetUserTrips<
  TData = Awaited<ReturnType<typeof usersGetUserTrips>>,
  TError = ErrorType<
    AuthenticationExceptionResponse | ModelNotFoundExceptionResponse | ValidationExceptionResponse
  >,
>(
  user: number,
  params: undefined | UsersGetUserTripsParams,
  options: {
    query: Partial<UseQueryOptions<Awaited<ReturnType<typeof usersGetUserTrips>>, TError, TData>> &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof usersGetUserTrips>>,
          TError,
          Awaited<ReturnType<typeof usersGetUserTrips>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useUsersGetUserTrips<
  TData = Awaited<ReturnType<typeof usersGetUserTrips>>,
  TError = ErrorType<
    AuthenticationExceptionResponse | ModelNotFoundExceptionResponse | ValidationExceptionResponse
  >,
>(
  user: number,
  params?: UsersGetUserTripsParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof usersGetUserTrips>>, TError, TData>> &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof usersGetUserTrips>>,
          TError,
          Awaited<ReturnType<typeof usersGetUserTrips>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useUsersGetUserTrips<
  TData = Awaited<ReturnType<typeof usersGetUserTrips>>,
  TError = ErrorType<
    AuthenticationExceptionResponse | ModelNotFoundExceptionResponse | ValidationExceptionResponse
  >,
>(
  user: number,
  params?: UsersGetUserTripsParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof usersGetUserTrips>>, TError, TData>>;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
/**
 * @summary List a user's trips with q search.
Returns code, path, status, date, id.
GET: /api/admin/users/{user}/trips
 */

export function useUsersGetUserTrips<
  TData = Awaited<ReturnType<typeof usersGetUserTrips>>,
  TError = ErrorType<
    AuthenticationExceptionResponse | ModelNotFoundExceptionResponse | ValidationExceptionResponse
  >,
>(
  user: number,
  params?: UsersGetUserTripsParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof usersGetUserTrips>>, TError, TData>>;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = useUsersGetUserTripsQueryOptions(user, params, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const usersGetCustomers = (
  params?: UsersGetCustomersParams,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<UsersGetCustomers200>(
    { url: `/customers`, method: "GET", params, signal },
    options,
  );
};

export const getUsersGetCustomersQueryKey = (params?: UsersGetCustomersParams) => {
  return [`/customers`, ...(params ? [params] : [])] as const;
};

export const useUsersGetCustomersQueryOptions = <
  TData = Awaited<ReturnType<typeof usersGetCustomers>>,
  TError = ErrorType<AuthenticationExceptionResponse | ValidationExceptionResponse>,
>(
  params?: UsersGetCustomersParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof usersGetCustomers>>, TError, TData>>;
    request?: SecondParameter<typeof customInstance>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getUsersGetCustomersQueryKey(params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof usersGetCustomers>>> = ({ signal }) =>
    usersGetCustomers(params, requestOptions, signal);

  const customOptions = infiniteOptions({ ...queryOptions, queryKey, queryFn });

  return customOptions as UseQueryOptions<
    Awaited<ReturnType<typeof usersGetCustomers>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type UsersGetCustomersQueryResult = NonNullable<
  Awaited<ReturnType<typeof usersGetCustomers>>
>;
export type UsersGetCustomersQueryError = ErrorType<
  AuthenticationExceptionResponse | ValidationExceptionResponse
>;

export function useUsersGetCustomers<
  TData = Awaited<ReturnType<typeof usersGetCustomers>>,
  TError = ErrorType<AuthenticationExceptionResponse | ValidationExceptionResponse>,
>(
  params: undefined | UsersGetCustomersParams,
  options: {
    query: Partial<UseQueryOptions<Awaited<ReturnType<typeof usersGetCustomers>>, TError, TData>> &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof usersGetCustomers>>,
          TError,
          Awaited<ReturnType<typeof usersGetCustomers>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useUsersGetCustomers<
  TData = Awaited<ReturnType<typeof usersGetCustomers>>,
  TError = ErrorType<AuthenticationExceptionResponse | ValidationExceptionResponse>,
>(
  params?: UsersGetCustomersParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof usersGetCustomers>>, TError, TData>> &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof usersGetCustomers>>,
          TError,
          Awaited<ReturnType<typeof usersGetCustomers>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useUsersGetCustomers<
  TData = Awaited<ReturnType<typeof usersGetCustomers>>,
  TError = ErrorType<AuthenticationExceptionResponse | ValidationExceptionResponse>,
>(
  params?: UsersGetCustomersParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof usersGetCustomers>>, TError, TData>>;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

export function useUsersGetCustomers<
  TData = Awaited<ReturnType<typeof usersGetCustomers>>,
  TError = ErrorType<AuthenticationExceptionResponse | ValidationExceptionResponse>,
>(
  params?: UsersGetCustomersParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof usersGetCustomers>>, TError, TData>>;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = useUsersGetCustomersQueryOptions(params, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary Store a new customer via Admin API (dedicated endpoint).
POST: /api/admin/customers
 */
export const usersStoreCustomer = (
  usersStoreCustomerBody: BodyType<UsersStoreCustomerBody>,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<UsersStoreCustomer201>(
    {
      url: `/customers`,
      method: "POST",
      headers: { "Content-Type": "application/json" },
      data: usersStoreCustomerBody,
      signal,
    },
    options,
  );
};

export const getUsersStoreCustomerMutationOptions = <
  TError = ErrorType<AuthenticationExceptionResponse | ValidationExceptionResponse>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof usersStoreCustomer>>,
    TError,
    { data: BodyType<UsersStoreCustomerBody> },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof usersStoreCustomer>>,
  TError,
  { data: BodyType<UsersStoreCustomerBody> },
  TContext
> => {
  const mutationKey = ["usersStoreCustomer"];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && "mutationKey" in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof usersStoreCustomer>>,
    { data: BodyType<UsersStoreCustomerBody> }
  > = (props) => {
    const { data } = props ?? {};

    return usersStoreCustomer(data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type UsersStoreCustomerMutationResult = NonNullable<
  Awaited<ReturnType<typeof usersStoreCustomer>>
>;
export type UsersStoreCustomerMutationBody = BodyType<UsersStoreCustomerBody>;
export type UsersStoreCustomerMutationError = ErrorType<
  AuthenticationExceptionResponse | ValidationExceptionResponse
>;

/**
 * @summary Store a new customer via Admin API (dedicated endpoint).
POST: /api/admin/customers
 */
export const useUsersStoreCustomer = <
  TError = ErrorType<AuthenticationExceptionResponse | ValidationExceptionResponse>,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof usersStoreCustomer>>,
      TError,
      { data: BodyType<UsersStoreCustomerBody> },
      TContext
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof usersStoreCustomer>>,
  TError,
  { data: BodyType<UsersStoreCustomerBody> },
  TContext
> => {
  const mutationOptions = getUsersStoreCustomerMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};
export const usersGetMemberships = (
  params?: UsersGetMembershipsParams,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<UsersGetMemberships200>(
    { url: `/memberships`, method: "GET", params, signal },
    options,
  );
};

export const getUsersGetMembershipsQueryKey = (params?: UsersGetMembershipsParams) => {
  return [`/memberships`, ...(params ? [params] : [])] as const;
};

export const useUsersGetMembershipsQueryOptions = <
  TData = Awaited<ReturnType<typeof usersGetMemberships>>,
  TError = ErrorType<AuthenticationExceptionResponse | ValidationExceptionResponse>,
>(
  params?: UsersGetMembershipsParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof usersGetMemberships>>, TError, TData>
    >;
    request?: SecondParameter<typeof customInstance>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getUsersGetMembershipsQueryKey(params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof usersGetMemberships>>> = ({ signal }) =>
    usersGetMemberships(params, requestOptions, signal);

  const customOptions = infiniteOptions({ ...queryOptions, queryKey, queryFn });

  return customOptions as UseQueryOptions<
    Awaited<ReturnType<typeof usersGetMemberships>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type UsersGetMembershipsQueryResult = NonNullable<
  Awaited<ReturnType<typeof usersGetMemberships>>
>;
export type UsersGetMembershipsQueryError = ErrorType<
  AuthenticationExceptionResponse | ValidationExceptionResponse
>;

export function useUsersGetMemberships<
  TData = Awaited<ReturnType<typeof usersGetMemberships>>,
  TError = ErrorType<AuthenticationExceptionResponse | ValidationExceptionResponse>,
>(
  params: undefined | UsersGetMembershipsParams,
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof usersGetMemberships>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof usersGetMemberships>>,
          TError,
          Awaited<ReturnType<typeof usersGetMemberships>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useUsersGetMemberships<
  TData = Awaited<ReturnType<typeof usersGetMemberships>>,
  TError = ErrorType<AuthenticationExceptionResponse | ValidationExceptionResponse>,
>(
  params?: UsersGetMembershipsParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof usersGetMemberships>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof usersGetMemberships>>,
          TError,
          Awaited<ReturnType<typeof usersGetMemberships>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useUsersGetMemberships<
  TData = Awaited<ReturnType<typeof usersGetMemberships>>,
  TError = ErrorType<AuthenticationExceptionResponse | ValidationExceptionResponse>,
>(
  params?: UsersGetMembershipsParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof usersGetMemberships>>, TError, TData>
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

export function useUsersGetMemberships<
  TData = Awaited<ReturnType<typeof usersGetMemberships>>,
  TError = ErrorType<AuthenticationExceptionResponse | ValidationExceptionResponse>,
>(
  params?: UsersGetMembershipsParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof usersGetMemberships>>, TError, TData>
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = useUsersGetMembershipsQueryOptions(params, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary Update a user's suspension state via Admin API.
If `suspension` is provided (boolean), set explicitly; otherwise toggle
 */
export const usersUpdateSuspension = (
  user: number,
  usersUpdateSuspensionBody: BodyType<UsersUpdateSuspensionBody>,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<UsersUpdateSuspension200>(
    {
      url: `/users/update-suspension/${user}`,
      method: "POST",
      headers: { "Content-Type": "application/json" },
      data: usersUpdateSuspensionBody,
      signal,
    },
    options,
  );
};

export const getUsersUpdateSuspensionMutationOptions = <
  TError = ErrorType<
    AuthenticationExceptionResponse | ModelNotFoundExceptionResponse | ValidationExceptionResponse
  >,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof usersUpdateSuspension>>,
    TError,
    { user: number; data: BodyType<UsersUpdateSuspensionBody> },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof usersUpdateSuspension>>,
  TError,
  { user: number; data: BodyType<UsersUpdateSuspensionBody> },
  TContext
> => {
  const mutationKey = ["usersUpdateSuspension"];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && "mutationKey" in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof usersUpdateSuspension>>,
    { user: number; data: BodyType<UsersUpdateSuspensionBody> }
  > = (props) => {
    const { user, data } = props ?? {};

    return usersUpdateSuspension(user, data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type UsersUpdateSuspensionMutationResult = NonNullable<
  Awaited<ReturnType<typeof usersUpdateSuspension>>
>;
export type UsersUpdateSuspensionMutationBody = BodyType<UsersUpdateSuspensionBody>;
export type UsersUpdateSuspensionMutationError = ErrorType<
  AuthenticationExceptionResponse | ModelNotFoundExceptionResponse | ValidationExceptionResponse
>;

/**
 * @summary Update a user's suspension state via Admin API.
If `suspension` is provided (boolean), set explicitly; otherwise toggle
 */
export const useUsersUpdateSuspension = <
  TError = ErrorType<
    AuthenticationExceptionResponse | ModelNotFoundExceptionResponse | ValidationExceptionResponse
  >,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof usersUpdateSuspension>>,
      TError,
      { user: number; data: BodyType<UsersUpdateSuspensionBody> },
      TContext
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof usersUpdateSuspension>>,
  TError,
  { user: number; data: BodyType<UsersUpdateSuspensionBody> },
  TContext
> => {
  const mutationOptions = getUsersUpdateSuspensionMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};
/**
 * @summary Get all available permissions grouped by category.
GET: /api/admin/permissions
 */
export const usersGetPermissions = (
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<UsersGetPermissions200>(
    { url: `/permissions`, method: "GET", signal },
    options,
  );
};

export const getUsersGetPermissionsQueryKey = () => {
  return [`/permissions`] as const;
};

export const useUsersGetPermissionsQueryOptions = <
  TData = Awaited<ReturnType<typeof usersGetPermissions>>,
  TError = ErrorType<AuthenticationExceptionResponse>,
>(options?: {
  query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof usersGetPermissions>>, TError, TData>>;
  request?: SecondParameter<typeof customInstance>;
}) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getUsersGetPermissionsQueryKey();

  const queryFn: QueryFunction<Awaited<ReturnType<typeof usersGetPermissions>>> = ({ signal }) =>
    usersGetPermissions(requestOptions, signal);

  const customOptions = infiniteOptions({ ...queryOptions, queryKey, queryFn });

  return customOptions as UseQueryOptions<
    Awaited<ReturnType<typeof usersGetPermissions>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type UsersGetPermissionsQueryResult = NonNullable<
  Awaited<ReturnType<typeof usersGetPermissions>>
>;
export type UsersGetPermissionsQueryError = ErrorType<AuthenticationExceptionResponse>;

export function useUsersGetPermissions<
  TData = Awaited<ReturnType<typeof usersGetPermissions>>,
  TError = ErrorType<AuthenticationExceptionResponse>,
>(
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof usersGetPermissions>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof usersGetPermissions>>,
          TError,
          Awaited<ReturnType<typeof usersGetPermissions>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useUsersGetPermissions<
  TData = Awaited<ReturnType<typeof usersGetPermissions>>,
  TError = ErrorType<AuthenticationExceptionResponse>,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof usersGetPermissions>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof usersGetPermissions>>,
          TError,
          Awaited<ReturnType<typeof usersGetPermissions>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useUsersGetPermissions<
  TData = Awaited<ReturnType<typeof usersGetPermissions>>,
  TError = ErrorType<AuthenticationExceptionResponse>,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof usersGetPermissions>>, TError, TData>
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
/**
 * @summary Get all available permissions grouped by category.
GET: /api/admin/permissions
 */

export function useUsersGetPermissions<
  TData = Awaited<ReturnType<typeof usersGetPermissions>>,
  TError = ErrorType<AuthenticationExceptionResponse>,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof usersGetPermissions>>, TError, TData>
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = useUsersGetPermissionsQueryOptions(options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary Get a single customer details (for edit form).
GET: /api/admin/customers/{user}
 */
export const usersShowCustomer = (
  user: number,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<UsersShowCustomer200>(
    { url: `/customers/${user}`, method: "GET", signal },
    options,
  );
};

export const getUsersShowCustomerQueryKey = (user?: number) => {
  return [`/customers/${user}`] as const;
};

export const useUsersShowCustomerQueryOptions = <
  TData = Awaited<ReturnType<typeof usersShowCustomer>>,
  TError = ErrorType<AuthenticationExceptionResponse | ModelNotFoundExceptionResponse>,
>(
  user: number,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof usersShowCustomer>>, TError, TData>>;
    request?: SecondParameter<typeof customInstance>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getUsersShowCustomerQueryKey(user);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof usersShowCustomer>>> = ({ signal }) =>
    usersShowCustomer(user, requestOptions, signal);

  const customOptions = infiniteOptions({ ...queryOptions, queryKey, queryFn });

  return customOptions as UseQueryOptions<
    Awaited<ReturnType<typeof usersShowCustomer>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type UsersShowCustomerQueryResult = NonNullable<
  Awaited<ReturnType<typeof usersShowCustomer>>
>;
export type UsersShowCustomerQueryError = ErrorType<
  AuthenticationExceptionResponse | ModelNotFoundExceptionResponse
>;

export function useUsersShowCustomer<
  TData = Awaited<ReturnType<typeof usersShowCustomer>>,
  TError = ErrorType<AuthenticationExceptionResponse | ModelNotFoundExceptionResponse>,
>(
  user: number,
  options: {
    query: Partial<UseQueryOptions<Awaited<ReturnType<typeof usersShowCustomer>>, TError, TData>> &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof usersShowCustomer>>,
          TError,
          Awaited<ReturnType<typeof usersShowCustomer>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useUsersShowCustomer<
  TData = Awaited<ReturnType<typeof usersShowCustomer>>,
  TError = ErrorType<AuthenticationExceptionResponse | ModelNotFoundExceptionResponse>,
>(
  user: number,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof usersShowCustomer>>, TError, TData>> &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof usersShowCustomer>>,
          TError,
          Awaited<ReturnType<typeof usersShowCustomer>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useUsersShowCustomer<
  TData = Awaited<ReturnType<typeof usersShowCustomer>>,
  TError = ErrorType<AuthenticationExceptionResponse | ModelNotFoundExceptionResponse>,
>(
  user: number,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof usersShowCustomer>>, TError, TData>>;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
/**
 * @summary Get a single customer details (for edit form).
GET: /api/admin/customers/{user}
 */

export function useUsersShowCustomer<
  TData = Awaited<ReturnType<typeof usersShowCustomer>>,
  TError = ErrorType<AuthenticationExceptionResponse | ModelNotFoundExceptionResponse>,
>(
  user: number,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof usersShowCustomer>>, TError, TData>>;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = useUsersShowCustomerQueryOptions(user, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary Update an existing customer via Admin API (dedicated endpoint).
PUT/PATCH: /api/admin/customers/{user}
 */
export const adminUsersUpdateCustomer1 = (
  user: number,
  adminUsersUpdateCustomer1Body: BodyType<AdminUsersUpdateCustomer1Body>,
  options?: SecondParameter<typeof customInstance>,
) => {
  return customInstance<AdminUsersUpdateCustomer1200>(
    {
      url: `/customers/${user}`,
      method: "PUT",
      headers: { "Content-Type": "application/json" },
      data: adminUsersUpdateCustomer1Body,
    },
    options,
  );
};

export const getAdminUsersUpdateCustomer1MutationOptions = <
  TError = ErrorType<
    AuthenticationExceptionResponse | ModelNotFoundExceptionResponse | ValidationExceptionResponse
  >,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof adminUsersUpdateCustomer1>>,
    TError,
    { user: number; data: BodyType<AdminUsersUpdateCustomer1Body> },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof adminUsersUpdateCustomer1>>,
  TError,
  { user: number; data: BodyType<AdminUsersUpdateCustomer1Body> },
  TContext
> => {
  const mutationKey = ["adminUsersUpdateCustomer1"];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && "mutationKey" in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof adminUsersUpdateCustomer1>>,
    { user: number; data: BodyType<AdminUsersUpdateCustomer1Body> }
  > = (props) => {
    const { user, data } = props ?? {};

    return adminUsersUpdateCustomer1(user, data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type AdminUsersUpdateCustomer1MutationResult = NonNullable<
  Awaited<ReturnType<typeof adminUsersUpdateCustomer1>>
>;
export type AdminUsersUpdateCustomer1MutationBody = BodyType<AdminUsersUpdateCustomer1Body>;
export type AdminUsersUpdateCustomer1MutationError = ErrorType<
  AuthenticationExceptionResponse | ModelNotFoundExceptionResponse | ValidationExceptionResponse
>;

/**
 * @summary Update an existing customer via Admin API (dedicated endpoint).
PUT/PATCH: /api/admin/customers/{user}
 */
export const useAdminUsersUpdateCustomer1 = <
  TError = ErrorType<
    AuthenticationExceptionResponse | ModelNotFoundExceptionResponse | ValidationExceptionResponse
  >,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof adminUsersUpdateCustomer1>>,
      TError,
      { user: number; data: BodyType<AdminUsersUpdateCustomer1Body> },
      TContext
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof adminUsersUpdateCustomer1>>,
  TError,
  { user: number; data: BodyType<AdminUsersUpdateCustomer1Body> },
  TContext
> => {
  const mutationOptions = getAdminUsersUpdateCustomer1MutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};
/**
 * @summary Update an existing customer via Admin API (dedicated endpoint).
PUT/PATCH: /api/admin/customers/{user}
 */
export const adminUsersUpdateCustomer2 = (
  user: number,
  adminUsersUpdateCustomer2Body: BodyType<AdminUsersUpdateCustomer2Body>,
  options?: SecondParameter<typeof customInstance>,
) => {
  return customInstance<AdminUsersUpdateCustomer2200>(
    {
      url: `/customers/${user}`,
      method: "PATCH",
      headers: { "Content-Type": "application/json" },
      data: adminUsersUpdateCustomer2Body,
    },
    options,
  );
};

export const getAdminUsersUpdateCustomer2MutationOptions = <
  TError = ErrorType<
    AuthenticationExceptionResponse | ModelNotFoundExceptionResponse | ValidationExceptionResponse
  >,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof adminUsersUpdateCustomer2>>,
    TError,
    { user: number; data: BodyType<AdminUsersUpdateCustomer2Body> },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof adminUsersUpdateCustomer2>>,
  TError,
  { user: number; data: BodyType<AdminUsersUpdateCustomer2Body> },
  TContext
> => {
  const mutationKey = ["adminUsersUpdateCustomer2"];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && "mutationKey" in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof adminUsersUpdateCustomer2>>,
    { user: number; data: BodyType<AdminUsersUpdateCustomer2Body> }
  > = (props) => {
    const { user, data } = props ?? {};

    return adminUsersUpdateCustomer2(user, data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type AdminUsersUpdateCustomer2MutationResult = NonNullable<
  Awaited<ReturnType<typeof adminUsersUpdateCustomer2>>
>;
export type AdminUsersUpdateCustomer2MutationBody = BodyType<AdminUsersUpdateCustomer2Body>;
export type AdminUsersUpdateCustomer2MutationError = ErrorType<
  AuthenticationExceptionResponse | ModelNotFoundExceptionResponse | ValidationExceptionResponse
>;

/**
 * @summary Update an existing customer via Admin API (dedicated endpoint).
PUT/PATCH: /api/admin/customers/{user}
 */
export const useAdminUsersUpdateCustomer2 = <
  TError = ErrorType<
    AuthenticationExceptionResponse | ModelNotFoundExceptionResponse | ValidationExceptionResponse
  >,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof adminUsersUpdateCustomer2>>,
      TError,
      { user: number; data: BodyType<AdminUsersUpdateCustomer2Body> },
      TContext
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof adminUsersUpdateCustomer2>>,
  TError,
  { user: number; data: BodyType<AdminUsersUpdateCustomer2Body> },
  TContext
> => {
  const mutationOptions = getAdminUsersUpdateCustomer2MutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};
/**
 * GET: /api/admin/customers/{user}/bundles
 * @summary List bundle memberships for a specific customer (Bundle tab ‚Äì audit table).
Supports simple `q` search, sorting and pagination similar to BundlesController@bundlesList
 */
export const usersGetCustomerBundles = (
  user: number,
  params?: UsersGetCustomerBundlesParams,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<UsersGetCustomerBundles200>(
    { url: `/customers/${user}/bundles`, method: "GET", params, signal },
    options,
  );
};

export const getUsersGetCustomerBundlesQueryKey = (
  user?: number,
  params?: UsersGetCustomerBundlesParams,
) => {
  return [`/customers/${user}/bundles`, ...(params ? [params] : [])] as const;
};

export const useUsersGetCustomerBundlesQueryOptions = <
  TData = Awaited<ReturnType<typeof usersGetCustomerBundles>>,
  TError = ErrorType<
    AuthenticationExceptionResponse | ModelNotFoundExceptionResponse | ValidationExceptionResponse
  >,
>(
  user: number,
  params?: UsersGetCustomerBundlesParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof usersGetCustomerBundles>>, TError, TData>
    >;
    request?: SecondParameter<typeof customInstance>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getUsersGetCustomerBundlesQueryKey(user, params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof usersGetCustomerBundles>>> = ({
    signal,
  }) => usersGetCustomerBundles(user, params, requestOptions, signal);

  const customOptions = infiniteOptions({ ...queryOptions, queryKey, queryFn });

  return customOptions as UseQueryOptions<
    Awaited<ReturnType<typeof usersGetCustomerBundles>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type UsersGetCustomerBundlesQueryResult = NonNullable<
  Awaited<ReturnType<typeof usersGetCustomerBundles>>
>;
export type UsersGetCustomerBundlesQueryError = ErrorType<
  AuthenticationExceptionResponse | ModelNotFoundExceptionResponse | ValidationExceptionResponse
>;

export function useUsersGetCustomerBundles<
  TData = Awaited<ReturnType<typeof usersGetCustomerBundles>>,
  TError = ErrorType<
    AuthenticationExceptionResponse | ModelNotFoundExceptionResponse | ValidationExceptionResponse
  >,
>(
  user: number,
  params: undefined | UsersGetCustomerBundlesParams,
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof usersGetCustomerBundles>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof usersGetCustomerBundles>>,
          TError,
          Awaited<ReturnType<typeof usersGetCustomerBundles>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useUsersGetCustomerBundles<
  TData = Awaited<ReturnType<typeof usersGetCustomerBundles>>,
  TError = ErrorType<
    AuthenticationExceptionResponse | ModelNotFoundExceptionResponse | ValidationExceptionResponse
  >,
>(
  user: number,
  params?: UsersGetCustomerBundlesParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof usersGetCustomerBundles>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof usersGetCustomerBundles>>,
          TError,
          Awaited<ReturnType<typeof usersGetCustomerBundles>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useUsersGetCustomerBundles<
  TData = Awaited<ReturnType<typeof usersGetCustomerBundles>>,
  TError = ErrorType<
    AuthenticationExceptionResponse | ModelNotFoundExceptionResponse | ValidationExceptionResponse
  >,
>(
  user: number,
  params?: UsersGetCustomerBundlesParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof usersGetCustomerBundles>>, TError, TData>
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
/**
 * @summary List bundle memberships for a specific customer (Bundle tab ‚Äì audit table).
Supports simple `q` search, sorting and pagination similar to BundlesController@bundlesList
 */

export function useUsersGetCustomerBundles<
  TData = Awaited<ReturnType<typeof usersGetCustomerBundles>>,
  TError = ErrorType<
    AuthenticationExceptionResponse | ModelNotFoundExceptionResponse | ValidationExceptionResponse
  >,
>(
  user: number,
  params?: UsersGetCustomerBundlesParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof usersGetCustomerBundles>>, TError, TData>
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = useUsersGetCustomerBundlesQueryOptions(user, params, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * POST: /api/admin/customers/{user}/bundle
Body: { "bundle_id": 123 }
 * @summary Change/attach bundle for a customer (Bundle tab ‚Äì Change button)
 */
export const usersChangeCustomerBundle = (
  user: number,
  usersChangeCustomerBundleBody: BodyType<UsersChangeCustomerBundleBody>,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<UsersChangeCustomerBundle200>(
    {
      url: `/customers/${user}/bundle`,
      method: "POST",
      headers: { "Content-Type": "application/json" },
      data: usersChangeCustomerBundleBody,
      signal,
    },
    options,
  );
};

export const getUsersChangeCustomerBundleMutationOptions = <
  TError = ErrorType<
    AuthenticationExceptionResponse | ModelNotFoundExceptionResponse | ValidationExceptionResponse
  >,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof usersChangeCustomerBundle>>,
    TError,
    { user: number; data: BodyType<UsersChangeCustomerBundleBody> },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof usersChangeCustomerBundle>>,
  TError,
  { user: number; data: BodyType<UsersChangeCustomerBundleBody> },
  TContext
> => {
  const mutationKey = ["usersChangeCustomerBundle"];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && "mutationKey" in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof usersChangeCustomerBundle>>,
    { user: number; data: BodyType<UsersChangeCustomerBundleBody> }
  > = (props) => {
    const { user, data } = props ?? {};

    return usersChangeCustomerBundle(user, data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type UsersChangeCustomerBundleMutationResult = NonNullable<
  Awaited<ReturnType<typeof usersChangeCustomerBundle>>
>;
export type UsersChangeCustomerBundleMutationBody = BodyType<UsersChangeCustomerBundleBody>;
export type UsersChangeCustomerBundleMutationError = ErrorType<
  AuthenticationExceptionResponse | ModelNotFoundExceptionResponse | ValidationExceptionResponse
>;

/**
 * @summary Change/attach bundle for a customer (Bundle tab ‚Äì Change button)
 */
export const useUsersChangeCustomerBundle = <
  TError = ErrorType<
    AuthenticationExceptionResponse | ModelNotFoundExceptionResponse | ValidationExceptionResponse
  >,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof usersChangeCustomerBundle>>,
      TError,
      { user: number; data: BodyType<UsersChangeCustomerBundleBody> },
      TContext
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof usersChangeCustomerBundle>>,
  TError,
  { user: number; data: BodyType<UsersChangeCustomerBundleBody> },
  TContext
> => {
  const mutationOptions = getUsersChangeCustomerBundleMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};
/**
 * DELETE: /api/admin/customers/{user}/bundle
 * @summary Detach any active bundle from a customer (Bundle tab ‚Äì Detach button)
 */
export const usersDetachCustomerBundle = (
  user: number,
  options?: SecondParameter<typeof customInstance>,
) => {
  return customInstance<UsersDetachCustomerBundle200>(
    { url: `/customers/${user}/bundle`, method: "DELETE" },
    options,
  );
};

export const getUsersDetachCustomerBundleMutationOptions = <
  TError = ErrorType<AuthenticationExceptionResponse | ModelNotFoundExceptionResponse>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof usersDetachCustomerBundle>>,
    TError,
    { user: number },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof usersDetachCustomerBundle>>,
  TError,
  { user: number },
  TContext
> => {
  const mutationKey = ["usersDetachCustomerBundle"];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && "mutationKey" in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof usersDetachCustomerBundle>>,
    { user: number }
  > = (props) => {
    const { user } = props ?? {};

    return usersDetachCustomerBundle(user, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type UsersDetachCustomerBundleMutationResult = NonNullable<
  Awaited<ReturnType<typeof usersDetachCustomerBundle>>
>;

export type UsersDetachCustomerBundleMutationError = ErrorType<
  AuthenticationExceptionResponse | ModelNotFoundExceptionResponse
>;

/**
 * @summary Detach any active bundle from a customer (Bundle tab ‚Äì Detach button)
 */
export const useUsersDetachCustomerBundle = <
  TError = ErrorType<AuthenticationExceptionResponse | ModelNotFoundExceptionResponse>,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof usersDetachCustomerBundle>>,
      TError,
      { user: number },
      TContext
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof usersDetachCustomerBundle>>,
  TError,
  { user: number },
  TContext
> => {
  const mutationOptions = getUsersDetachCustomerBundleMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};
/**
 * PATCH: /api/admin/customers/{user}/memberships/{member}/extra-items
 * @summary Update extra items for a specific membership record (Bundle tab ‚Äì inline Edit/Save)
 */
export const usersUpdateMembershipExtraItems = (
  user: number,
  member: number,
  usersUpdateMembershipExtraItemsBody: BodyType<UsersUpdateMembershipExtraItemsBody>,
  options?: SecondParameter<typeof customInstance>,
) => {
  return customInstance<UsersUpdateMembershipExtraItems200>(
    {
      url: `/customers/${user}/memberships/${member}/extra-items`,
      method: "PATCH",
      headers: { "Content-Type": "application/json" },
      data: usersUpdateMembershipExtraItemsBody,
    },
    options,
  );
};

export const getUsersUpdateMembershipExtraItemsMutationOptions = <
  TError = ErrorType<
    AuthenticationExceptionResponse | ModelNotFoundExceptionResponse | ValidationExceptionResponse
  >,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof usersUpdateMembershipExtraItems>>,
    TError,
    { user: number; member: number; data: BodyType<UsersUpdateMembershipExtraItemsBody> },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof usersUpdateMembershipExtraItems>>,
  TError,
  { user: number; member: number; data: BodyType<UsersUpdateMembershipExtraItemsBody> },
  TContext
> => {
  const mutationKey = ["usersUpdateMembershipExtraItems"];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && "mutationKey" in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof usersUpdateMembershipExtraItems>>,
    { user: number; member: number; data: BodyType<UsersUpdateMembershipExtraItemsBody> }
  > = (props) => {
    const { user, member, data } = props ?? {};

    return usersUpdateMembershipExtraItems(user, member, data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type UsersUpdateMembershipExtraItemsMutationResult = NonNullable<
  Awaited<ReturnType<typeof usersUpdateMembershipExtraItems>>
>;
export type UsersUpdateMembershipExtraItemsMutationBody =
  BodyType<UsersUpdateMembershipExtraItemsBody>;
export type UsersUpdateMembershipExtraItemsMutationError = ErrorType<
  AuthenticationExceptionResponse | ModelNotFoundExceptionResponse | ValidationExceptionResponse
>;

/**
 * @summary Update extra items for a specific membership record (Bundle tab ‚Äì inline Edit/Save)
 */
export const useUsersUpdateMembershipExtraItems = <
  TError = ErrorType<
    AuthenticationExceptionResponse | ModelNotFoundExceptionResponse | ValidationExceptionResponse
  >,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof usersUpdateMembershipExtraItems>>,
      TError,
      { user: number; member: number; data: BodyType<UsersUpdateMembershipExtraItemsBody> },
      TContext
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof usersUpdateMembershipExtraItems>>,
  TError,
  { user: number; member: number; data: BodyType<UsersUpdateMembershipExtraItemsBody> },
  TContext
> => {
  const mutationOptions = getUsersUpdateMembershipExtraItemsMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};
export const usersGetDrivers = (
  params?: UsersGetDriversParams,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<UsersGetDrivers200>(
    { url: `/drivers`, method: "GET", params, signal },
    options,
  );
};

export const getUsersGetDriversQueryKey = (params?: UsersGetDriversParams) => {
  return [`/drivers`, ...(params ? [params] : [])] as const;
};

export const useUsersGetDriversQueryOptions = <
  TData = Awaited<ReturnType<typeof usersGetDrivers>>,
  TError = ErrorType<AuthenticationExceptionResponse | ValidationExceptionResponse>,
>(
  params?: UsersGetDriversParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof usersGetDrivers>>, TError, TData>>;
    request?: SecondParameter<typeof customInstance>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getUsersGetDriversQueryKey(params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof usersGetDrivers>>> = ({ signal }) =>
    usersGetDrivers(params, requestOptions, signal);

  const customOptions = infiniteOptions({ ...queryOptions, queryKey, queryFn });

  return customOptions as UseQueryOptions<
    Awaited<ReturnType<typeof usersGetDrivers>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type UsersGetDriversQueryResult = NonNullable<Awaited<ReturnType<typeof usersGetDrivers>>>;
export type UsersGetDriversQueryError = ErrorType<
  AuthenticationExceptionResponse | ValidationExceptionResponse
>;

export function useUsersGetDrivers<
  TData = Awaited<ReturnType<typeof usersGetDrivers>>,
  TError = ErrorType<AuthenticationExceptionResponse | ValidationExceptionResponse>,
>(
  params: undefined | UsersGetDriversParams,
  options: {
    query: Partial<UseQueryOptions<Awaited<ReturnType<typeof usersGetDrivers>>, TError, TData>> &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof usersGetDrivers>>,
          TError,
          Awaited<ReturnType<typeof usersGetDrivers>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useUsersGetDrivers<
  TData = Awaited<ReturnType<typeof usersGetDrivers>>,
  TError = ErrorType<AuthenticationExceptionResponse | ValidationExceptionResponse>,
>(
  params?: UsersGetDriversParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof usersGetDrivers>>, TError, TData>> &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof usersGetDrivers>>,
          TError,
          Awaited<ReturnType<typeof usersGetDrivers>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useUsersGetDrivers<
  TData = Awaited<ReturnType<typeof usersGetDrivers>>,
  TError = ErrorType<AuthenticationExceptionResponse | ValidationExceptionResponse>,
>(
  params?: UsersGetDriversParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof usersGetDrivers>>, TError, TData>>;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

export function useUsersGetDrivers<
  TData = Awaited<ReturnType<typeof usersGetDrivers>>,
  TError = ErrorType<AuthenticationExceptionResponse | ValidationExceptionResponse>,
>(
  params?: UsersGetDriversParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof usersGetDrivers>>, TError, TData>>;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = useUsersGetDriversQueryOptions(params, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}
